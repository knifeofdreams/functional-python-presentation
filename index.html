<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>FUNctional programming in Python</title>

    <meta name="description"
          content="A quick example to demonstrate whether Python is really a good tool for functional programming.">
    <meta name="author" content="Judit Ordog-Andrasi">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/dark.css">
    <!--<link rel="stylesheet" href="lib/css/dracula.css">-->
    <!--<link rel="stylesheet" href="lib/css/far.css">-->
    <!--<link rel="stylesheet" href="lib/css/gruvbox-dark.css">-->
    <!--<link rel="stylesheet" href="lib/css/ir-black.css">-->
    <!--<link rel="stylesheet" href="lib/css/pojoaque.css">-->
    <!--<link rel="stylesheet" href="lib/css/tomorrow-night-bright.css">-->
    <!--<link rel="stylesheet" href="lib/css/idea.css">-->
    <!--<link rel="stylesheet" href="lib/css/default.css">-->
    <!--<link rel="stylesheet" href="lib/css/arduino-light.css">-->
    <!--<link rel="stylesheet" href="lib/css/ascetic.css">-->
    <!--<link rel="stylesheet" href="lib/css/github.css">-->
    <!--<link rel="stylesheet" href="lib/css/github-gist.css">-->
    <!--<link rel="stylesheet" href="lib/css/googlecode.css">-->

    <style>
        .reveal pre code {
            max-height:1000px;
        }
    </style>

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <h1>FUNctional programming in Python</h1>

            <h3>Can Python really be functional?</h3>

            <p>
                <small>Inspired by Attila Magyar / <a href="http://twitter.com/athoshun">@athoshun</a><br>
                Created by Judit Ordog-Andrasi / <a href="http://twitter.com/knifeofdreams">@knifeofdreams</a>
                </small>
            </p>
            <aside class="notes">
                <p>Credits to Athos</p>
                <p>At Prezi it's very in, so I wanted to know more about it myself</p>
                <p>I'm far from professional, but I was very curious, so I started to learn about it.</p>
            </aside>
        </section>

        <section>
            <h1>FizzBuzz</h1>
        </section>

        <section>
            <h3>Write a program that iterates through the numbers from 1 to 100 and:</h3>
            <ul>
                <li>For multiples of <b>3</b> return <b>"Fizz"</b>
                <li>For multiples of <b>5</b> return <b>"Buzz"</b>
                <li>For numbers which are multiples of <b>both 3 and 5</b> return <b>"FizzBuzz"</b>
                <li>For others, return the number itself
            </ul>
        </section>

        <section>
            <p style="font-size:150%">
                1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz
                11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz
                Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz
                31 32 Fizz 34 Buzz Fizz 37 38 Fizz Buzz
                41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 Buzz
                Fizz 52 53 Fizz Buzz 56 Fizz 58 59 FizzBuzz
                61 62 Fizz 64 Buzz Fizz 67 68 Fizz Buzz
                71 Fizz 73 74 FizzBuzz 76 77 Fizz 79 Buzz
                Fizz 82 83 Fizz Buzz 86 Fizz 88 89 FizzBuzz
                91 92 Fizz 94 Buzz Fizz 97 98 Fizz Buzz
            </p>
            <aside class="notes">
                <p>The result looks something like this.</p>
            </aside>
        </section>


        <section>
                <h2>Trivial solution</h2>
                <pre><code data-trim>
def fizzbuzz():
    result = []
    for i in range(1,101):
        if (i % 3 == 0 and i % 5 == 0):
            result.append("FizzBuzz")
        elif (i % 3 == 0):
            result.append("Fizz")
        elif (i % 5 == 0):
            result.append("Buzz")
        else:
            result.append(str(i))
    return result
                </code></pre>
                <aside class="notes">
                    <p>This is my trivial solution.</p>
                    <p>You can solve it differently, but the majority of the first impression solutions will be like this.</p>
                    <p>One for loop and a couple of if statements.</p>
                </aside>
        </section>

        <section>
                <h2>Unit test</h2>
                <pre><code data-trim>
import unittest

from fizzbuzz import fizzbuzz

class FizzBuzzTest(unittest.TestCase):
    def test_fizzbuzz_should_return_fizzbuzz_array(self):
        result = ["1", "2", "Fizz", "4", "Buzz", "Fizz", "7", "8", "Fizz", "Buzz",
                "11", "Fizz", "13", "14", "FizzBuzz", "16", "17", "Fizz", "19", "Buzz",
                "Fizz", "22", "23", "Fizz", "Buzz", "26", "Fizz", "28", "29", "FizzBuzz",
                "31", "32", "Fizz", "34", "Buzz", "Fizz", "37", "38", "Fizz", "Buzz",
                "41", "Fizz", "43", "44", "FizzBuzz", "46", "47", "Fizz", "49", "Buzz",
                "Fizz", "52", "53", "Fizz", "Buzz", "56", "Fizz", "58", "59", "FizzBuzz",
                "61", "62", "Fizz", "64", "Buzz", "Fizz", "67", "68", "Fizz", "Buzz",
                "71", "Fizz", "73", "74", "FizzBuzz", "76", "77", "Fizz", "79", "Buzz",
                "Fizz", "82", "83", "Fizz", "Buzz", "86", "Fizz", "88", "89", "FizzBuzz",
                "91", "92", "Fizz", "94", "Buzz", "Fizz", "97", "98", "Fizz", "Buzz"]
        self.assertEqual(result, fizzbuzz())

if __name__ == '__main__':
    unittest.main()
                </code></pre>
            <aside class="notes">
                <p>If you know me then you'll know that I'm a huge fan of TDD.</p>
                <p>This time I didn't use tedious TDD, I only wrote this one unit test.</p>
                <p>At every stage of that I'm showing you today this test case was green.</p>
            </aside>
        </section>

        <section>
                <h1>No for loops!</h1>
            <aside class="notes">
                <p>So basically if you don't want to start from FP, you can also make relatively simple problems more interesting by using restrictions.</p>
                <p>Like not using any for loops</p>
            </aside>
        </section>

        <section>
                <h2>Recursion</h2>
                <pre><code data-trim>
def fizzbuzz(number = 100):
    if number < 1:
        return []

    if (number % 3 == 0 and number % 5 == 0):
        result = "FizzBuzz"
    elif (number % 3 == 0):
        result = "Fizz"
    elif (number % 5 == 0):
        result = "Buzz"
    else:
        result = str(number)

    return fizzbuzz(number - 1) + [result]
                </code></pre>

            <aside class="notes">
                <p>For loop was quite a central element in this kata previously.</p>
                <p>What's the first solution that comes to mind: maybe recursion.</p>
                <p>There is no for loop, but we have another if statement that will stop recursion when we reach the end of our range.</p>
                <p>We start of with a default parameter then the function calls itself with a parameter reduced by one.</p>
            </aside>
        </section>

        <section>
            <h2>Extract fizzbuzz of n function</h2>
                <pre><code data-trim>
def fizzbuzz_of_n(number):
    if (number % 3 == 0 and number % 5 == 0):
        return "FizzBuzz"
    elif (number % 3 == 0):
        return "Fizz"
    elif (number % 5 == 0):
        return "Buzz"
    else:
        return str(number)


def fizzbuzz(number = 100):
    if number < 1:
        return []

    return fizzbuzz(number - 1) + [fizzbuzz_of_n(number)]
                </code></pre>

            <aside class="notes">
                <p>This is all nice, but it's using a lot of memory, and usually it's not the best option to eat up all the stack on the machine.</p>
                <p>Extracting function.</p>
            </aside>
        </section>

        <section>
                <h2>Map in fizzbuzz</h2>
                <pre><code data-trim>
def fizzbuzz_of_n(number):
    if (number % 3 == 0 and number % 5 == 0):
        return "FizzBuzz"
    elif (number % 3 == 0):
        return "Fizz"
    elif (number % 5 == 0):
        return "Buzz"
    else:
        return str(number)


def fizzbuzz():
    return map(fizzbuzz_of_n, range(1,101))


.
                </code></pre>
            <aside class="notes">
                <p>Another solution instead of using recusrion could be a built-it iterator function.</p>
                <p>This one is called map</p>
            </aside>
        </section>


        <section>
            <h1>No if statement!</h1>
        </section>

        <section>
                <h1>Ugly code ahead!</h1>
            <img src="4fd55b0558273.png" height="300px">

            <aside class="notes">
                <p>Not how I usually write code.</p>
                <p>This is a stretch exercise so that we can learn new things.</p>
                <p>The conclusion is still going to be interesting.</p>
            </aside>
        </section>

        <section>
            <h2>Repeating pattern</h2>
            <pre style="font-size:70%">
 1  2 Fizz  4 Buzz Fizz  7  8 Fizz Buzz 11 Fizz 13 14 FizzBuzz
16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz
31 32 Fizz 34 Buzz Fizz 37 38 Fizz Buzz 41 Fizz 43 44 FizzBuzz
46 47 Fizz 49 Buzz Fizz 52 53 Fizz Buzz 56 Fizz 58 59 FizzBuzz
61 62 Fizz 64 Buzz Fizz 67 68 Fizz Buzz 71 Fizz 73 74 FizzBuzz
76 77 Fizz 79 Buzz Fizz 82 83 Fizz Buzz 86 Fizz 88 89 FizzBuzz
91 92 Fizz 94 Buzz Fizz 97 98 Fizz Buzz
            </pre>
            <aside class="notes">
                <p>In order to be able to get rid of the if statements we have to see the recurring pattern in the results of fizzbuzz.</p>
                <p>Pattern repeats at every 15 values.</p>
            </aside>
        </section>

        <section>
            <h2>Helper functions</h2>
                <pre><code data-trim>
id_ = lambda number: str(number)
                </code></pre>
            <aside class="notes">
                <p>We need a couple of helper functions.</p>
                <p>The first one is a lambda that receives a parameter and returns the string representation of the param.</p>
                <p>Not the most clever function, but it's gonna be very useful.</p>
            </aside>
        </section>

        <section>
            <h2>Helper functions</h2>
                <pre><code data-trim>
id_ = lambda number: str(number)
fizz_ = lambda number: "Fizz"
buzz_ = lambda number: "Buzz"
fizzbuzz_ = lambda number: "FizzBuzz"
                </code></pre>
            <aside class="notes">
                <p>We are introducing other lambdas for the constants.</p>
                <p>They are even less clever: they receive a parameter a return a constant string.</p>
            </aside>
        </section>

        <section>
                <h2>Lambdas everywhere!</h2>
                <pre><code data-trim>
def fizzbuzz():
    return map(lambda number: fizzbuzz_lambdas[number % 15](number), range(1,101))

id_ = lambda number: str(number)
fizz_ = lambda number: "Fizz"
buzz_ = lambda number: "Buzz"
fizzbuzz_ = lambda number: "FizzBuzz"

fizzbuzz_lambdas = [
    fizzbuzz_, id_, id_, fizz_, id_,
    buzz_, fizz_, id_, id_, fizz_,
    buzz_, id_, fizz_, id_, id_
]
                </code></pre>
            <aside class="notes">
                <p>This is how we can use them.</p>
                <p>We can put these lambdas into a list.</p>
                <p>In fizzbuzz we are iterating over the same range as before, but</p>
                <p>We execute a lambda that receives a parameter and based on the modulo of the parameter with 15</p>
                <p>It will call a lambda from the fizzbuzz_lambdas list with the number as a parameter.</p>
            </aside>
        </section>

        <section>
            <h2>Redundancy</h2>
                <pre>
def fizzbuzz():
    return map(lambda number: fizzbuzz_lambdas[number % 15](number), range(1,101))

id_ = lambda number: str(number)
<span style="color: red;">fizz_ = lambda number: "Fizz"
buzz_ = lambda number: "Buzz"
fizzbuzz_ = lambda number: "FizzBuzz"</span>

fizzbuzz_lambdas = [
    fizzbuzz_, id_, id_, fizz_, id_,
    buzz_, fizz_, id_, id_, fizz_,
    buzz_, id_, fizz_, id_, id_
]
                </pre>
            <aside class="notes">
                <p>We eliminated all our if statements, but!</p>
                <p>We have this ugly redundancy in our code!</p>
                <p>Let's get rid of this.</p>
            </aside>
        </section>

        <section>
            <h2>Higher order function</h2>
                <pre><code data-trim>
def const(constant):
    return lambda number: constant



.
                </code></pre>
            <aside class="notes">
                <p>We can extract a function called const that return a lambda returning a constant.</p>
                <p>This is our first high-order function.</p>
            </aside>
        </section>

        <section>
            <h2>Higher order function</h2>
                <pre><code data-trim>
def const(constant):
    return lambda number: constant

fizz_ = const("Fizz")
buzz_ = const("Buzz")
fizzbuzz_ = const("FizzBuzz")

                </code></pre>
            <aside class="notes">
                <p>And this is how we can use it for our lambdas.</p>
            </aside>
        </section>

        <section>
            <section>
                <h2>Higher order function</h2>
                <pre><code data-trim>
def fizzbuzz():
    return map(lambda number: fizzbuzz_lambdas[number % 15](number), range(1,101))

def const(constant):
    return lambda number: constant

id_ = lambda number: str(number)
fizz_ = const("Fizz")
buzz_ = const("Buzz")
fizzbuzz_ = const("FizzBuzz")

fizzbuzz_lambdas = [
    fizzbuzz_, id_, id_, fizz_, id_,
    buzz_, fizz_, id_, id_, fizz_,
    buzz_, id_, fizz_, id_, id_
]
                </code></pre>
            </section>
            <aside class="notes">
                <p>This is how the whole code will look like.</p>
            </aside>
        </section>

        <section>
            <section>
                <h2>We're not repeating repeating ourselves... right?</h2>
            </section>
        </section>

        <section>
            <h2>Ugly duplication!</h2>
                <pre><code data-trim>
fizz_ = const("Fizz")
buzz_ = const("Buzz")
fizzbuzz_ = const("FizzBuzz")
                </code></pre>
            <img src="scared-cat.jpg" height="300">
            <aside class="notes">
                <p>Terrible ugly duplication.</p>
                <p>What a hack!</p>
                <p>Fight it with iron fist!</p>
            </aside>
        </section>

        <section>
            <h2>I heard you like functions...</h2>
                <pre><code data-trim>
def concat(f, g):
    return lambda number: f(number) + g(number)



.
                </code></pre>

            <aside class="notes">
                <p>I heard you like functions.</p>
                <p>So here is a function that takes functions and returns you another function.</p>
            </aside>
        </section>

        <section>
            <h2>I heard you like functions...</h2>
                <pre><code data-trim>
def concat(f, g):
    return lambda number: f(number) + g(number)

fizz_ = const("Fizz")
buzz_ = const("Buzz")
fizzbuzz_ = concat(fizz_, buzz_)
                </code></pre>
            <aside class="notes">
                <p>Now we can use this concat for FizzBuzz. Pheuw.</p>
            </aside>
        </section>

        <section>
                <h2>Concat fizzbuzz</h2>
                <pre><code data-trim>
def fizzbuzz():
    return map(lambda number: fizzbuzz_lambdas[number % 15](number), range(1,101))

def const(constant):
    return lambda number: constant

def concat(f, g):
    return lambda number: f(number) + g(number)

id_ = lambda number: str(number)
fizz_ = const("Fizz")
buzz_ = const("Buzz")
fizzbuzz_ = concat(fizz_, buzz_)

fizzbuzz_lambdas = [
    fizzbuzz_, id_, id_, fizz_, id_,
    buzz_, fizz_, id_, id_, fizz_,
    buzz_, id_, fizz_, id_, id_
]
                </code></pre>
            <aside class="notes">
                <p>It's started to look like some actual code!</p>
                <p>Finally!</p>
            </aside>
        </section>

        <section>
                <h1>Can we do better?</h1>
        </section>

        <section>
            <img src="yes-we-can.jpg" height="450">
        </section>

        <section>
            <h2>Typed manually!</h2>
                <pre><code data-trim>
fizzbuzz_lambdas = [
                        fizzbuzz_, id_, id_, fizz_, id_,
                        buzz_, fizz_, id_, id_, fizz_,
                        buzz_, id_, fizz_, id_, id_
                    ]
                </code></pre>
        </section>

        <section>
            <img src="e12f29127a72de73e8921ccf3c3993ea.jpg">
        </section>

        <section>
            <h2>Helper functions</h2>
                <pre><code data-trim>
def multiples_of(n):
    return map(lambda i: i * n, range(1, 10))

multiples_of(3)
[3, 6, 9, 12, 15, 18, 21, 24, 27]

multiples_of(5)
[5, 10, 15, 20, 25, 30, 35, 40, 45]
                </code></pre>
            <aside class="notes">
                <p>The first helper function will take a number and return its multiples on a range from 1 to 10.</p>
            </aside>
        </section>

        <section>
            <h2>Helper functions</h2>
                <pre><code data-trim>
def take(n, list):
    return list[:n]

multiples_of_3 = take(4, multiples_of(3))
[3, 6, 9, 12]

multiples_of_5 = take(2, multiples_of(5))
[5, 10]
                </code></pre>
            <aside class="notes">
                <p>Take will return the first n elements of a list.</p>
                <p>For the repetitive pattern we will need the first 4 multiples of 3 and first 2 multiples of 5.</p>
                <p>We can generate those like this.</p>
            </aside>
        </section>

        <section>
            <h2>Helper functions</h2>
                <pre><code data-trim>
def substract(list_from, what_list):
    return list(set(list_from) - set(what_list))

substract([1,2,3],[3,4,5])
[1, 2]
                </code></pre>
            <aside class="notes">
                <p>Substract does what it says: substracts the list from another.</p>
            </aside>
        </section>

        <section>
            <h2>Generated subsets</h2>
                <pre><code data-trim>
multiples_of_3 = take(4, multiples_of(3))
[3, 6, 9, 12]
multiples_of_5 = take(2, multiples_of(5))
[5, 10]
multiples_of_both = [0]
[0]
others = substract(range(1,15), multiples_of_3 + multiples_of_5)
[1, 2, 4, 7, 8, 11, 13, 14]
                </code></pre>
            <aside class="notes">
                <p>With their help these are our subsets for the 15 element pattern.</p>
                <p>Multiples of 3, 5, 3 and 5 and the rest.</p>
            </aside>
        </section>

        <section>
            <h2>Zip it up!</h2>
                <pre><code data-trim>
zip([1, 2, 3], ['a', 'b', 'c'])
[(1, 'a'), (2, 'b'), (3, 'c')]

dict(zip([1, 2, 3], ['a', 'b', 'c']))
{1: 'a', 2: 'b', 3: 'c'}
                </code></pre>
            <aside class="notes">
                <p>The next helper is zip that combines two list into the list of tuples.</p>
                <p>It will pair the elements with the same index.</p>
            </aside>
        </section>

        <section>
            <h2>Zip it up!</h2>
                <pre><code data-trim>
zip([3, 6, 9, 12], [fizz_, fizz_, fizz_, fizz_])
[(3, fizz_), (6, fizz_), (9, fizz_), (12, fizz_)]

dict(zip([3, 6, 9, 12], [fizz_, fizz_, fizz_, fizz_]))
{9: fizz_, 3: fizz_, 12: fizz_, 6: fizz_}
                </code></pre>
            <aside class="notes">
                <p>Instead of arbitrary valeus we can use a list of the multiples of three, and a list with the fuzz lambdas.</p>
                <p>We can covert zips output into a dictionary.</p>
                <p>A key-value store data structure.</p>
            </aside>
        </section>

        <section>
            <h2>Repeat Repeat Repeat Repeat...</h2>
                <pre><code data-trim>
def repeat(value, times):
    return [value] * times

repeat(4,7)
[4, 4, 4, 4, 4, 4, 4]
                </code></pre>
            <aside class="notes">
                <p>We will need the repeat function.</p>
                <p>It repeats a value as many times as the parameter says.</p>
            </aside>
        </section>

        <section>
            <h2>Zip it up!</h2>
                <pre><code data-trim>
zip([3, 6, 9, 12], repeat(fizz_, 4))
[(3, fizz_), (6, fizz_), (9, fizz_), (12, fizz_)]

dict(zip([3, 6, 9, 12], repeat(fizz_, 4)))
{9: fizz_, 3: fizz_, 12: fizz_, 6: fizz_}
                </code></pre>
            <aside class="notes">
                <p>With using the repeat function we don't need to do as much manual work.</p>
                <p>Here is the final dictionary for the multiples of 3 with numbers as keys and fizz lambdas as values.</p>
            </aside>
        </section>

        <section>
            <h2>Generalize the solution</h2>
                <pre><code data-trim>
zip([3, 6, 9, 12], repeat(fizz_, 4))
[(3, fizz_), (6, fizz_), (9, fizz_), (12, fizz_)]

dict(zip([3, 6, 9, 12], repeat(fizz_, 4)))
{9: fizz_, 3: fizz_, 12: fizz_, 6: fizz_}

def for_all(value, function):
    return dict(zip(value, repeat(function, len(value))))
                </code></pre>
            <aside class="notes">
                <p>We can put all of this into a function which I named for all.</p>
            </aside>
        </section>

        <section>
            <h2>So we have our dictionaries</h2>
                <pre><code data-trim>
for_all(multiples_of_3, fizz_)
{9: fizz_, 3: fizz_, 12: fizz_, 6: fizz_}

for_all(multiples_of_5, buzz_)
{5: buzz_, 10: buzz_}

for_all(multiples_of_both, fizzbuzz_)
{0: fizzbuzz_}

                </code></pre>
            <aside class="notes">
                <p>We can use this for all function for every subset that we generated so far to get our dictionaries.</p>
            </aside>
        </section>

        <section>
            <h2>All we need is a combine!</h2>
            <img src="148_859.jpg" height="450">
        </section>

        <section>
            <h2>All we need is a combine</h2>
                <pre><code data-trim>
def combine_two_dicts(lhs, rhs):
    result = lhs.copy()
    result.update(rhs)
    return result

combine_two_dicts({9: fizz_, 3: fizz_, 12: fizz_, 6: fizz_},{5: buzz_, 10: buzz_})
{3: fizz_, 5: buzz_, 6: fizz_, 9: fizz_, 10: buzz_, 12: fizz_}
                </code></pre>
            <aside class="notes">
                <p>Update is mutable, and for FP that's a big NO-NO.</p>
                <p>One would be tempted to use a for loop, but we can't.</p>
            </aside>
        </section>

        <section>
            <h2>All we need is a combine</h2>
                <pre><code data-trim>
def combine_two_dicts(lhs, rhs):
    result = lhs.copy()
    result.update(rhs)
    return result

def combine_dicts(*dict_args):
    return reduce(combine_two_dicts, dict_args, {})

combine_dicts({1: 'a'}, {2: 'b'}, {3: 'c'})
{1: 'a', 2: 'b', 3: 'c'}
                </code></pre>
            <aside class="notes">
                <p>We can generalize and write a combine for any number of dicts.</p>
                <p>We use reduce that will combine all the iterable objects into a single value with the function that we pass as a param.</p>
            </aside>
        </section>

        <section>
            <section>
                <table style="border: solid 0px;">
                    <tr>
                        <td style="border: solid 0px;">fizzbuzz_lambdas =</td>
                        <td style="border: solid 0px;">combine_dicts(</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all(multiples_of_3, fizz_),</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all(multiples_of_5, buzz_),</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all(multiples_of_both, fizzbuzz_),</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all(others, id_)</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">)</td>
                    </tr>

                </table>

            </section>
            <aside class="notes">
                <p>This is almost readable.</p>
            </aside>
        </section>

        <section>
                <h2>Increase readability</h2>
                <pre><code data-trim>
def return_(x):
    return x

it_ = lambda number: str(number)
                </code></pre>
            <aside class="notes">
                <p>Aptly named return function.</p>
                <p>Guess what it does.</p>
                <p>Renamed id to it.</p>
            </aside>
        </section>

        <section>
            <section>
                <table style="border: solid 0px;">
                    <tr>
                        <td style="border: solid 0px;">fizzbuzz_lambdas =</td>
                        <td style="border: solid 0px;">combine_dicts(</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all(multiples_of_3, return_(fizz_)),</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all(multiples_of_5, return_(buzz_)),</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all(multiples_of_both, return_(fizzbuzz_)),</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all(others, return_(it_))</td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">)</td>
                    </tr>

                </table>

            </section>
            <aside class="notes">
                <p>So with all this, this is our final result.</p>
            </aside>
        </section>

        <section>
            <section>
                <table style="border: solid 0px;">
                    <tr>
                        <td style="border: solid 0px;">fizzbuzz<span style="opacity: 0.25;">_lambdas </span>=</td>
                        <td style="border: solid 0px;"><span style="opacity: 0.25;">combine_dicts(</span></td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all<span style="opacity: 0.25;">(</span>multiples_of_3, return<span style="opacity: 0.25;">_(</span>fizz<span style="opacity: 0.25;">_)),</span></td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all<span style="opacity: 0.25;">(</span>multiples_of_5, return<span style="opacity: 0.25;">_(</span>buzz<span style="opacity: 0.25;">_)),</span></td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all<span style="opacity: 0.25;">(</span>multiples_of_both, return<span style="opacity: 0.25;">_(</span>fizzbuzz<span style="opacity: 0.25;">_)),</span></td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;">for_all<span style="opacity: 0.25;">(</span>others, return<span style="opacity: 0.25;">_(</span>it<span style="opacity: 0.25;">_))</span></td>
                    </tr>
                    <tr>
                        <td style="border: solid 0px;"></td>
                        <td style="border: solid 0px;"><span style="opacity: 0.25;">)</span></td>
                    </tr>

                </table>
            </section>
            <aside class="notes">
                <p>If I grey out the boiler plate we basically get the definition of fizzbuzz that we saw on the first slide.</p>
                <p>This is is quite a wow moment after all the complexity that we introduced.</p>
            </aside>
        </section>


        <section>
                <h2>Generators</h2>
                <pre><code data-trim>
.

def multiples_of(n):
    return map(lambda i: i * n, range(1, 10))




def take(n, list):
    return list[:n]
                </code></pre>
            <aside class="notes">
                <p>Range is a bit arbitrary.</p>
                <p>Why 10? What if we used 1 million?</p>
                <p>Eat up a lot of memory.</p>
            </aside>
        </section>


        <section>
                <h2>Generators</h2>
                <pre><code data-trim>
import itertools

def multiples_of(n):
    i = 0
    while True:
        i += 1
        yield n*i

def take(n, generator):
    return list(itertools.islice(generator, 0, n))

                </code></pre>
            <aside class="notes">
                <p>With this multiples of n becomes an infinite generator.</p>
                <p>islice creates a finite generator from an infinite one.</p>
                <p>list call creates a finite list from the generator. Lazy evaluation here.</p>
                <p>We only generate values when list is called.</p>
                <p>Oh Noes! We did it again! We used a while loop!.</p>
            </aside>
        </section>

        <section>
                <h2>Generators</h2>
                <pre><code data-trim>
import itertools

def multiples_of(n):
    return itertools.count(n, n)




def take(n, generator):
    return list(itertools.islice(generator, 0, n))

                </code></pre>
            <aside class="notes">
                <p>Luckily we have a function for that.</p>
                <p>Steps from a starting number by an offset.</p>
                <p>In our case we start from n and step with an offset n.</p>
            </aside>
        </section>

        <section>
                <h2>Don't try this at home</h2>
            <p>Inefficient memory usage</p>
            <p>Slow</p>
            <p>Building your own toolset</p>
            <p>Readability issues</p>
            <img src="danger.jpg" alt="Danger" height="200">
        </section>

        <section>
            <section>
                <h2>Try this at home</h2>
                    <p>Different mindset</p>
                    <p>Good practises (no side effects, built-in functions)</p>
                    <p>Multithreading</p>
                    <p>Bigger toolset == improved problem solving</p>
            </section>
        </section>

        <section>
            <section>
                <h1>Thank you for your attention!</h1>
            </section>
        </section>

    </div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        width: 1200,
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'plugin/notes/notes.js', async: true}
        ]
    });

</script>

</body>
</html>
